\section{Normalization}
    For most numerical code significant computational gains can be achieved
    relatively easy by smart normalization. With a succesful normalization most
    of the multiplications with constants will dissappear. Numerical errors
    due to machine precision are smallest close to unity, \(\order{1}\), (Find Citation) so we
    want to work with numbers as close to unity as we can. As a sidebenefit it also
    makes the code easier to write and cleaner to read. Consider a single particle,
    with mass \(m\) and charge \(q\), in an electric field \(\vb{E}\). Its equation of motion is then

    \begin{align}
        m\pdv[2]{\vb{r}}{t} &= q\vb{E}
    \end{align}

    To compute the acceleration of this particle completely naive would at each point
    cost \(1\) multiplications and \(1\) division, \(m/q*E\). If we instead use smartly normalized
    values the equation could look like this

    \begin{align}
        \pdv[2]{\tilde {\vb{r}}}{t} &= \tilde{\vb{E}}
    \end{align}

    where \(\tilde {\vb{r}}\) and \(\tilde{\vb{E}}\) is normalized so the dimensionality of the
    equation works out. Here we get away with no multiplications and no divisions,
    but we do have the added task of transforming our variables first to the normalized variables
    and then back to the original after the simulation has run.

    \subsection{Non-dimensionality PinC}
        A good dimensionalizing strategy is to first remove
        dimensionality from the fundamental quantities, and then work out the
        normalizations necessary for the derived quantities.

        The fundamental quantities that are involved in our PiC simulation is
        mass \(m\), position \(\vb{r}\), time \(t\) and charge \(q\). Since we are dealing with
        plasma it is useful to normalize with Debye-length, \(\lambda_D\), and electron plasma frequency, \(\omega_{pe}\).
        The normalized quantities are then:

        \begin{subequations}
	        \begin{equation}
	            \tilde{\vb{r} }= \frac{\vb{r}}{\lambda_D} \label{eq:pos_nondim}
	        \end{equation}
	        \begin{equation}
	            \tilde {t} = \omega_{pe} t	\label{eq:time_nondim}
	        \end{equation}
			\begin{equation}
				\tilde m = \frac{m}{m_e}	\label{eq:mass_nondim}
			\end{equation}
			\begin{equation}
				\tilde q = \frac{q}{e}	\label{eq:charge_nondim}
			\end{equation}
    	\end{subequations}

		Next we need the velocity, which is the temporal derivative of
		the position. This is normalized by transforming the position to the
		nondimensional position, by \cref{eq:pos_nondim}, as well as changing the temporal derivative
		to a nondimensional temporal, by \cref{eq:time_nondim}.

		\begin{equation}
			\pdv{\vb{r}}{t} = v \quad \rightarrow  \quad \pdv{\tilde{\vb{r}}}{\tilde t} = \tilde{\vb{v}} = \frac{\vb{v}}{v_{th}}
		\end{equation}

        Here we have introduced the thermal velocity \(v_th = \lambda_{De} \omega_{pe}\).

		Now we will use the Lorentz force to normalize the electromagnetic fields.

 		\begin{equation}
 			\pdv{\vb{v}}{t} = \frac{q}{m}\left( \vb{E} + \vb{v}\cross \vb{B} \right)
 		\end{equation}

		Swapping in all the nondimensional values from \cref{eq:pos_nondim,eq:time_nondim,eq:mass_nondim,eq:charge_nondim}
		we obtain

		\begin{equation}
            \pdv{(\tilde{\vb{v}}v_{th})}{(\tilde{t}/{\omega_{pe}})}
            = \frac{(\tilde{q}e)}{(\tilde{m}m_e)}\left( \vb{E} + (\vb{v}v_{th})\cross \vb{B} \right)
		\end{equation}
		\begin{equation}
			\pdv{\tilde{\vb{v}}}{\tilde{t}} =
            \frac{\tilde q}{\tilde m} \left(\frac{e}{v_{th}\omega_{pe}m_e}\vb{E}
            + \tilde{\vb{v}} \cross  \frac{e}{\omega_{pe}m_e}\vb{B}
 			 \right)
		\end{equation}

        This suggests that we use the following nondimensionalized fields

        \begin{equation*}
            \tilde{\vb{E}} = \frac{e}{v_{th}\omega_{pe}m_e}\vb{E} \quad{\text{and}} \quad \tilde{\vb{B}} = \frac{e}{\omega_{pe}m_e}\vb{B}
        \end{equation*}

		Check equation against dimensionalizing chart... (And get proper results in terms og kT on so on)



    \subsection{Normalization PinC}
        It should be mentioned that the normalization scheme for PinC was mostly worked
        out by Sigvald Marholm, and I am mostly repeating his work here. It still needs
        to be in this work to get a complete understanding of our PiC implementation.
