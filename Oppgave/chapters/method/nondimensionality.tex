\section{Normalization}
    For most numerical code significant computational gains can be achieved
    relatively easy by smart normalization. With a succesful normalization most
    of the multiplications with constants will dissappear. Numerical errors
    due to machine precision are smallest close to unity, \(\order{1}\), (Find Citation) so we
    want to work with numbers as close to unity as we can. As a sidebenefit it also
    makes the code easier to write and cleaner to read. Consider a single particle,
    with mass \(m\) and charge \(q\), in an electric field \(\vb{E}\). Its equation of motion is then

    \begin{align}
        m\pdv[2]{\vb{r}}{t} &= q\vb{E}
    \end{align}

    To compute the acceleration of this particle completely naive would at each point
    cost \(1\) multiplications and \(1\) division, \(m/q*E\). If we instead use smartly normalized
    values the equation could look like this

    \begin{align}
        \pdv[2]{\tilde {\vb{r}}}{t} &= \tilde{\vb{E}}
    \end{align}

    where \(\tilde {\vb{r}}\) and \(\tilde{\vb{E}}\) is normalized so the dimensionality of the
    equation works out. Here we get away with no multiplications and no divisions,
    but we do have the added task of transforming our variables first to the normalized variables
    and then back to the original after the simulation has run.

    \subsection{Non-dimensionality PinC}
        A good dimensionalizing strategy is to first remove
        dimensionality from the fundamental quantities, and then work out the
        normalizations necessary for the derived quantities.

        The fundamental quantities that are involved in our PiC simulation is
        mass \(m\), position \(\vb{r}\), time \(t\) and charge \(q\). Since we are dealing with
        plasma it is useful to normalize with Debye-length, \(\lambda_D\), and electron plasma frequency, \(\omega_{pe}\).
        The normalized quantities are then:

        \begin{subequations}
	        \begin{equation}
	            \tilde{\vb{r} }= \frac{\vb{r}}{\lambda_D} \label{eq:pos_nondim}
	        \end{equation}
	        \begin{equation}
	            \tilde {t} = \omega_{pe} t	\label{eq:time_nondim}
	        \end{equation}
			\begin{equation}
				\tilde m = \frac{m}{m_e}	\label{eq:mass_nondim}
			\end{equation}
			\begin{equation}
				\tilde q = \frac{q}{e}	\label{eq:charge_nondim}
			\end{equation}
    	\end{subequations}

		Next we need the velocity, which is the temporal derivative of
		the position. This is normalized by transforming the position to the
		nondimensional position, by \cref{eq:pos_nondim}, as well as changing the temporal derivative
		to a nondimensional temporal, by \cref{eq:time_nondim}.

		\begin{equation}
			\pdv{\vb{r}}{t} = v \quad \rightarrow  \quad \pdv{\tilde{\vb{r}}}{\tilde t} = \tilde{\vb{v}} = \frac{\vb{v}}{v_{th}}
		\end{equation}

        Here we have introduced the thermal velocity, mentioned in \cref{sec:parameters}, \(v_{th} = \lambda_{De} \omega_{pe}\).

		Now we will use the Lorentz force to normalize the electromagnetic fields.

 		\begin{equation}
 			\pdv{\vb{v}}{t} = \frac{q}{m}\left( \vb{E} + \vb{v}\cross \vb{B} \right)
 		\end{equation}

		Swapping in all the nondimensional values from \cref{eq:pos_nondim,eq:time_nondim,eq:mass_nondim,eq:charge_nondim}
		we obtain

		\begin{equation}
            \pdv{(\tilde{\vb{v}}v_{th})}{(\tilde{t}/{\omega_{pe}})}
            = \frac{(\tilde{q}e)}{(\tilde{m}m_e)}\left( \vb{E} + (\vb{v}v_{th})\cross \vb{B} \right)
		\end{equation}
		\begin{equation}
			\pdv{\tilde{\vb{v}}}{\tilde{t}} =
            \frac{\tilde q}{\tilde m} \left(\frac{e}{v_{th}\omega_{pe}m_e}\vb{E}
            + \tilde{\vb{v}} \cross  \frac{e}{\omega_{pe}m_e}\vb{B}
 			 \right)
		\end{equation}

        This suggests that we use the following nondimensionalized fields

        \begin{equation}
            \tilde{\vb{E}} = \frac{e}{v_{th}\omega_{pe}m_e}\vb{E} \quad{\text{and}} \quad \tilde{\vb{B}} = \frac{e}{\omega_{pe}m_e}\vb{B}
        \end{equation}

        The electric field is related to the charge density \(\rho\) through Gauss'
        law.

        \begin{equation}
            \nabla \cdot \vb{E} = \frac{\rho}{\epsilon_0}
        \end{equation}

        Inserting normalized quantities for \(\vb{E}\) and the gradient operator
        \[\tilde{\nabla}=\left(\pdv{\tilde x}, \pdv{\tilde y} , \pdv{\tilde z}\right) = \lambda_D \nabla\]

        \begin{equation}
            \frac{1}{\lambda_D}\tilde\nabla \cdot \frac{v_{th}\omega_{pe}m_e}{e}\tilde{\vb{E}} = \frac{\rho}{\epsilon_0}
        \end{equation}
        \begin{equation}
            \tilde\nabla \cdot\tilde{\vb{E}} = \frac{\lambda_De}{v_{th}\omega_{pe}m_e}\frac{\rho}{\epsilon_0}
        \end{equation}
        This gives the dimensionless charge density
        \begin{equation}
            \tilde \rho = \frac{\rho}{n_0e}
        \end{equation}

        (NOTE TO SELF: I think Sigvalds notes had an error in his dimensionless E and B)

    \subsection{Normalization PinC}
        It should be mentioned that the normalization scheme for PinC was mostly worked
        out by Sigvald Marholm, and I am mostly repeating his work here. It is still
        included here to give complete understanding of our PiC implementation.
        The general aim of the normalization scheme is to reduce the number of
        floating point operations on the particles. Since there are usually
        fewer grid points, i.e. values for fields such as \(\rho\) and \(\vb{E}\),
        than particles in a simulation a multiplication should preferably be done to
        a field instead of each particle. From now on we will omit the \(~\) on dimensionless
        quantities and consider all quantities dimensionless.
\\ \\
        (NOTE TO SELF: I think Sigvald had maybe erroneously used \(\frac{(\Delta t)^2}{\Delta x \Delta y \Delta z}\) during the normalization of
        \(\vb{E}\), this is not the same as \(\frac{(\Delta t)^2}{\Delta \vb{r}}\), but there are more errors.)
\\ \\(ExtraNote TO SELF: Not sure if this was actually correct and how it was implemented, or
        where the discretization normalization of E is.)
\\ \\(ExtraEaxtraNOTE TO SELF: Why was not gNormalizeE used??)
\\ \\ (NOTE TO SELF: Fix problem with E normalization, tomorrow. Write time (Also discovered problem with rho sign (+-), appearent if only
    one specie, can be because I don't have a rho neutralize function, should write that sometime))

        \subsection{Mover}
            We use the Leapfrog algorithm from \textit{\citetitle{birdsall_plasma_2004}} \citep{birdsall_plasma_2004}
            book. This has the perks of second order accuracy and stability for oscillatory motion
            with the same number of function calls as Euler integration. It is
            a momentum conserving algorithm. Here we assume that we have a solver
            that will give us an electric field.

            The finite difference discretization of a leapfrog step is given by

            \begin{equation}
                \frac{\vb{r}^{n+1}-\vb{r}^n}{\Delta t} = \vb{v}^{n+\frac{1}{2}}
            \end{equation}
