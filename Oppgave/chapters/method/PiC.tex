\section{Particle-in-Cell}

    Particle based plasma simulations has been in use since the 1960s, \citep{verboncoeur_particle_2005},
    and part of this project was to design a massively parrallel implementation,
    with a focus on the Poisson solver.
    The aim of this chapter is to describe simple and fast PiC model, with good scaling properties, as a baseline
    and rather add in extra functionality later. Due to this it uses an electrostatic model and
    ignores relativistic effects, which makes it faster and more suited to certain tasks.
    (Probably mention which tasks! Need to find out)
    For a modern relativistic full electromagnetic model see
    \citet{sgattoni_piccante:_2015}.

    The first particle based plasma calculations was
    was done by \cite{dawson_one-dimensional_1962} and \citet{buneman_dissipation_1959}.
    They computed the electrical force directly between the particles leading
    to a computational scaling of \(\order{(\#particles)^2}\).
    Since a large number of particles is often wanted the PiC method seeks to improve
    the scaling by computing the force on the particles from an electric field instead.
    The electric field is computed from the charge distribution computed from the
    particles. For an electrostatic model, as this code is, this is usually done by solving the Poisson
    equation, \cref{eq:poisson}, over the whole domain, \(\Omega\).
    The input to the solver is the charge density, \(\rho\), and the output is the potential, \(\Phi\).

    \begin{align}
        \nabla ^2 \Phi &= -\rho \qquad \text{in} \qquad \Omega \label{eq:poisson}
    \end{align}

    See \cref{fig:schematic} for an overview of the PiC cycle.
    The mover moves all the particles, in our case this is done by either a
    leapfrog, or boris algorithm in the case of an external magnetic field.
    The distribute process computes a charge distribution, which is done by first
    order interpolation.
    The solver computes an electric, or the elecromagnetic fields, this is done by
    a multigrid solver.
    Lastly the accelerator updates the velocities according to the fields.

    \begin{figure}
        \center
        \input{tikz/PiC_fig}
        \caption{Schematic overview of the PIC cycle. The mover moves all the particles,
        then the charges are distributed onto a charge density grid. The solver then
        obtains a electric field before the accelerate sets a new velocity to the particles.}
        \label{fig:schematic}
    \end{figure}

    \subsection{Field Solvers}
    The Poisson equation, \cref{eq:Poisson}, is a well known and investigated problem.
    Here we will mention some advantages and disadvantages of different possible
    field solvers before we describe our choice of a multigrid solver.

    \subsubsection{Spectral Methods} (NOTE TO SELF: Shen no fourier transform, find different source, Name what \(A and B\) are.)
    	The spectral methods is based on Fourier transforms of the problem and solving
    	the problem in it's spectral version, see \citep{shen_efficient_1994}, for an
    	implementation of an spectral Poisson solver. They are efficient solvers that
    	can be less intricate to implement, but can be inaccurate for complex geometries.

    	When looking for a solution with a spectral method we first rewrite the
    	functions as Fourier series, which for the three-dimensional Poisson equation would be

    	\begin{align}
    		\nabla^2 \sum A_{j,k,l} e^{i(jx + ky + lz)} &= \sum B_{j,k,l} e^{i(jx + ky + lz)}
    		\intertext{From there we get a relation between the coefficients}
    		A_{j,k,l} &= -\frac{B_{j,k,l}}{j^2 + k^2 + l^2}
    		\intertext{Then we compute the Fourier transform of the right hand side obtaining
    		the coefficients \(B_{j,k,l}\). We compute all the coefficients \(A_{j,k,l}\)
    		from the relation between the coefficients. At last we perform a inverse
    		Fourier transform of the left hand side obtaining the solution.}
    	\end{align}

    \subsubsection{Finite Element Methods}

    	The finite element, (FEM), is a method to numerically solve a partial differential
    	equations (PDE) first transforming the problem into a variational problem and
    	then constructing a mesh and local trial functions, see \cite{alnaes_fenics_2011}
    	for a more complete discussion.

    	To transform the PDE to a variational problem we first multiply the PDE by a
    	test function \(v\), then it is integrated using integration by parts on the
    	second order terms. Then the problem is separated into two parts, the bilinear
    	form \(a(u,v)\) containing the unknown solution and the test function and the
    	linear form \(L(v)\) containing only the test function.

    	\begin{align}
    		a(u,v) = L(v)	\qquad v\epsilon \hat{V}
    	\end{align}


    	Next we construct discrete local function spaces of that we assume contain
    	the trialfunctions and testfunctions. The function space, \(\hat{V}\), often consists of
    	locally defined functions that are \(0\) except in a close neighbourhood of
    	a mesh point, so the resulting matrix to be solved is sparse and can be computed
    	quickly. The matrix system is then solved by a suiting linear algebra algorithm,
    	before the solution is put together. The FEM method is very suited to tackling problems
        on complicated grids.

    \subsubsection{Multigrid}

        The multigrid method used to solve the Poisson equation and obtain the
        electric field is a widely used and highly efficient solver for elliptic equations,
        having a theoretical scaling of \(\order{N}\) \citep{press_numerical_1988},
        where \(N\) is the grid points. It is very well suited to simple geometries
        that can easily be translated to coarser problems. Due to this it we have chosen
        to use it as the solver in our PiC model.
        The multigrid method is based on iterative
        solvers such as Gauss-Seidel, \cref{sec:GSRB}, these have the property
        that they quickly eliminate local errors in the solution, while far
        away influences takes longer to incorporate. Multigrid algorithms tries
        to lessen this problem by transforming this problem to a coarser grid
        so the distant errors gets solved in fewer iterations. Due to this it needs
        algorithms to transfer the problem between coarser and finer grids, which
        is called restrictors and prolongators. The multigrid algorithm is described in
        more detail in \cref{sec:multigrid}.
