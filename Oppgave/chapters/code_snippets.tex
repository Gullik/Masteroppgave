%%%%%%%%%%%%%%%%%%%%%%%%%MG-Cycles%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
	\subsection{V-cycle, code}
	\label{sec:mg_V}
	\begin{lstlisting}[language=c, caption = Implementation of an recursive V-cycle]
void inline static mgVRecursive(int level, int bottom, int top, Multigrid *mgRho, Multigrid *mgPhi,
 									Multigrid *mgRes, const MpiInfo *mpiInfo){

	//Solve and return at coarsest level
	if(level == bottom){
		gInteractHalo(setSlice, mgPhi->grids[level], mpiInfo);
		mgRho->coarseSolv(mgPhi->grids[level], mgRho->grids[level], mgRho->nCoarseSolve, mpiInfo);
		mgRho->prolongator(mgRes->grids[level-1], mgPhi->grids[level], mpiInfo);
		return;
	}

	//Gathering info
	int nPreSmooth = mgRho->nPreSmooth;
	int nPostSmooth= mgRho->nPostSmooth;

	Grid *phi = mgPhi->grids[level];
	Grid *rho = mgRho->grids[level];
	Grid *res = mgRes->grids[level];

	//Boundary
	gInteractHalo(setSlice, rho, mpiInfo);
	gBnd(rho,mpiInfo);

	//Prepare to go down
	mgRho->preSmooth(phi, rho, nPreSmooth, mpiInfo);
	mgResidual(res, rho, phi, mpiInfo);
	gInteractHalo(setSlice, res, mpiInfo);
	gBnd(res, mpiInfo);

	//Go down
	mgRho->restrictor(res, mgRho->grids[level + 1]);
	mgVRecursive(level + 1, bottom, top, mgRho, mgPhi, mgRes, mpiInfo);

	//Prepare to go up
	gAddTo( phi, res );
	gInteractHalo(setSlice, phi,mpiInfo);
	gBnd(phi,mpiInfo);
	mgRho->postSmooth(phi, rho, nPostSmooth, mpiInfo);

	//Go up
	if(level > top){
		mgRho->prolongator(mgRes->grids[level-1], phi, mpiInfo);
	}
	return;
}
	\end{lstlisting}

\newpage
\begin{lstlisting}[language=c, caption = Implementation of an recursive V-cycle]
void mgVRegular(int level, int bottom, int top, Multigrid *mgRho, Multigrid *mgPhi,
 									Multigrid *mgRes, const MpiInfo *mpiInfo){

	//Gathering info
	int nPreSmooth = mgRho->nPreSmooth;
	int nPostSmooth= mgRho->nPostSmooth;
	int nCoarseSolv= mgRho->nCoarseSolve;


	//Down to coarsest level
	for(int current = level; current <bottom; current ++){
		//Load grids
		Grid *phi = mgPhi->grids[current];
		Grid *rho = mgRho->grids[current];
		Grid *res = mgRes->grids[current];

		//Boundary
		gInteractHalo(setSlice, phi,mpiInfo);
		gBnd(phi,mpiInfo);

		mgRho->preSmooth(phi, rho, nPreSmooth, mpiInfo);
		mgResidual(res, rho, phi, mpiInfo);
		mgRho->restrictor(res, mgRho->grids[current + 1]);
	}

	//Solve at coarsest
	gInteractHalo(setSlice, mgRho->grids[bottom], mpiInfo);
	gBnd(mgRho->grids[bottom],mpiInfo);
	mgRho->coarseSolv(mgPhi->grids[bottom], mgRho->grids[bottom], nCoarseSolv, mpiInfo);
	mgRho->prolongator(mgRes->grids[bottom-1], mgPhi->grids[bottom], mpiInfo);

	//Up to finest
	for(int current = bottom-1; current >-1; current --){
		//Load grids
		Grid *phi = mgPhi->grids[current];
		Grid *rho = mgRho->grids[current];
		Grid *res = mgRes->grids[current];


		//Prepare to go up
		gAddTo( phi, res );
		gInteractHalo(setSlice, phi,mpiInfo);
		gBnd(phi,mpiInfo);
		mgRho->postSmooth(phi, rho, nPostSmooth, mpiInfo);
		if(level > top)	mgRho->prolongator(mgRes->grids[current-1], phi, mpiInfo);
	}

	return;
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%Prolongators/Restrictors%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
The direct insertion is done similar to the previously described in the restriction section, \ref{sec:restriction}.
\begin{lstlisting}[language=c, caption = Codesnippet for the Z Y and X sweeps]
//Interpolation 3rd Dim
f = fSizeProd[1] + fSizeProd[2] + 2*fSizeProd[3];
fNext = f + fSizeProd[3];
fPrev = f - fSizeProd[3];

for(int l = 0; l < fTrueSize[3]; l+=2){
	for(int k = 0; k < fSize[2]; k+=2){
		for(int j = 0; j < fSize[1]; j+=2){
			fVal[f] = 0.5*(fVal[fPrev]+fVal[fNext]);
			f +=2;
			fNext +=2;
			fPrev +=2;
		}
		f		+=fSizeProd[2];
		fNext 	+=fSizeProd[2];
		fPrev 	+=fSizeProd[2];
	}
	f		+=fSizeProd[3];
	fNext 	+=fSizeProd[3];
	fPrev 	+=fSizeProd[3];
}

gSwapHalo(fine, mpiInfo, 2);

//Interpolation 2nd Dim
f = fSizeProd[1] + 2*fSizeProd[2] + fSizeProd[3];
fNext = f + fSizeProd[2];
fPrev = f - fSizeProd[2];

for(int l = 0; l < fTrueSize[3]; l++){
	for(int k = 0; k < fSize[2]; k+=2){
		for(int j = 0; j < fSize[1]; j+=2){
			fVal[f] = 0.5*(fVal[fPrev]+fVal[fNext]);
			f +=2;
			fNext +=2;
			fPrev +=2;
		}
		f		+=fSizeProd[2];
		fNext 	+=fSizeProd[2];
		fPrev 	+=fSizeProd[2];
	}
}

gSwapHalo(fine, mpiInfo, 1);

//Interpolation 2nd Dim
f = 2*fSizeProd[1] + fSizeProd[2] + fSizeProd[3];
fNext = f + fSizeProd[1];
fPrev = f - fSizeProd[1];

for(int l = 0; l < fTrueSize[3]; l++){
	for(int k = 0; k < fTrueSize[2]; k++){
		for(int j = 0; j < fSize[1]; j+=2){
			fVal[f] = 0.5*(fVal[fPrev]+fVal[fNext]);
			f +=2;
			fNext +=2;
			fPrev +=2;
		}
	}
	f		+=2*fSizeProd[2];
	fNext 	+=2*fSizeProd[2];
	fPrev 	+=2*fSizeProd[2];
}
\end{lstlisting}


\begin{lstlisting}[language=c,  caption = Setting the stencil indexes]
	//Indexes
	long int c = cSizeProd[1]*nGhostLayers[1] + cSizeProd[2]*nGhostLayers[2] + cSizeProd[3]*nGhostLayers[3];

	long int f = fSizeProd[1]*nGhostLayers[1] + fSizeProd[2]*nGhostLayers[2] + fSizeProd[3]*nGhostLayers[3];
	long int fj  = f + fSizeProd[1];
	long int fjj = f - fSizeProd[1];
	long int fk  = f + fSizeProd[2];
	long int fkk = f - fSizeProd[2];
	long int fl  = f + fSizeProd[3];
	long int fll = f - fSizeProd[3];
\end{lstlisting}


\newpage
\begin{lstlisting}[language=c, caption = The foor loop doing the calculations]
	//Cycle Coarse grid
	for(int l = 0; l<cTrueSize[3]; l++){
		for(int k = 0; k < cTrueSize[2]; k++){
			for(int j = 0; j < cTrueSize[1]; j++){
				cVal[c] = coeff*(6*fVal[f] + fVal[fj] + fVal[fjj] + fVal[fk] + fVal[fkk] + fVal[fl] + fVal[fll]);
				c++;
				f  +=2;
				fj +=2;
				fjj+=2;
				fk +=2;
				fkk+=2;
				fl +=2;
				fll+=2;
			}
			c  += cKEdgeInc;
			f  += fKEdgeInc;
			fj += fKEdgeInc;
			fjj+= fKEdgeInc;
			fk += fKEdgeInc;
			fkk+= fKEdgeInc;
			fl += fKEdgeInc;
			fll+= fKEdgeInc;
		}
		c  += cLEdgeInc;
		f  += fLEdgeInc;
		fj += fLEdgeInc;
		fjj+= fLEdgeInc;
		fk += fLEdgeInc;
		fkk+= fLEdgeInc;
		fl += fLEdgeInc;
		fll+= fLEdgeInc;
	}
\end{lstlisting}

As of now there is 2 seperate implementations, for 2 and 3 dimensions.



%%%%%%%%%%%%%%%%%%%%%%%%%Iterative Solvers%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Iterative solvers}
\subsection{Jacobian code}
\label{sec:jacobian}

\begin{lstlisting}[language=c, caption = Code snippet 2D jacobian]
  for(int c = 0; c < nCycles; c++){
    // Index of neighboring nodes
    int gj = sizeProd[1];
    int gjj= -sizeProd[1];
    int gk = sizeProd[2];
    int gkk= -sizeProd[2];

    for(long int g = 0; g < sizeProd[rank]; g++){
      tempVal[g] = 0.25*(	phiVal[gj] + phiVal[gjj] +
                phiVal[gk] + phiVal[gkk] + rhoVal[g]);

      gj++;
      gjj++;
      gk++;
      gkk++;
    }

    for(int q = 0; q < sizeProd[rank]; q++) phiVal[q] = tempVal[q];
    for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
  }
\end{lstlisting}

% \newpage
% \subsection{GS-RB 2D}
% \label{sec:GS_RB_2D}
% \begin{lstlisting}[language=c, caption = Main loop]
%     for(int c = 0; c < nCycles;c++){
%
%       //Increments
%       int kEdgeInc = nGhostLayers[2] + nGhostLayers[rank + 2] + sizeProd[2];
%
%       /**************************
%        *	Red Pass
%        *************************/
%       //Odd numbered rows
%       g = nGhostLayers[1] + sizeProd[2];
%       loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);
%
%       //Even numbered columns
%       g = nGhostLayers[1] + 1 + 2*sizeProd[2];
%       loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);
%
%       for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
%
%       /***********************************
%        *	Black pass
%        **********************************/
%       //Odd numbered rows
%       g = nGhostLayers[1] + 1 + sizeProd[2];
%       loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);
%
%       //Even numbered columns
%       g = nGhostLayers[1] + 2*sizeProd[2];
%       loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);
%
%
%       for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
%     }
%
%     return;
%   }
% \end{lstlisting}

% \begin{lstlisting}[language=c, caption = Loop through grid]
%   gj = g + sizeProd[1];
%   gjj= g - sizeProd[1];
%   gk = g + sizeProd[2];
%   gkk= g - sizeProd[2];
%
%   for(int k = 1; k < trueSize[2]; k +=2){
%     for(int j = 1; j < trueSize[1]; j += 2){
%       phiVal[g] = 0.25*(	phiVal[gj] + phiVal[gjj] +
%                 phiVal[gk] + phiVal[gkk] + rhoVal[g]);
%       g	+=2;
%       gj	+=2;
%       gjj	+=2;
%       gk	+=2;
%       gkk	+=2;
%     }
%     g	+=kEdgeInc;
%     gj	+=kEdgeInc;
%     gjj	+=kEdgeInc;
%     gk	+=kEdgeInc;
%     gkk	+=kEdgeInc;
%   }
% \end{lstlisting}

\newpage
\subsection{GS-RB 3D if tests}
\label{sec:GS-RB_if}
\begin{lstlisting}[language=c, caption = GS-RB with if-tests]

  /*********************
   *	Red Pass
   ********************/
  g = sizeProd[3]*nGhostLayers[3];
  for(int l = 0; l < trueSize[3];l++){
    for(int k = 0; k < size[2]; k++){
      for(int j = 0; j < size[1]; j+=2){
        phiVal[g] = 0.125*(	phiVal[g+gj] + phiVal[g-gj] +
                  phiVal[g+gk] + phiVal[g-gk] +
                  phiVal[g+gl] + phiVal[g-gl] + rhoVal[g]);
        g	+=2;
      }
      if(l%2){
        if(k%2)	g+=1; else g-=1;
      } else {
        if(k%2) g-=1; else g+=1;
      }

    }
    if(l%2) g-=1; else g+=1;
  }

  for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
\end{lstlisting}

\newpage
\subsection{GS-RB 3D without if tests}
\begin{lstlisting}[language=c, caption = main routine]
/**************************
 *	Red Pass
 *************************/
//Odd layers - Odd Rows
g = nGhostLayers[1]*sizeProd[1] + nGhostLayers[2]*sizeProd[2] + nGhostLayers[3]*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

//Odd layers - Even Rows
g = (nGhostLayers[1]+1)*sizeProd[1] + (nGhostLayers[2]+1)*sizeProd[2] + nGhostLayers[3]*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

//Even layers - Odd Rows
g = (nGhostLayers[1])*sizeProd[1] + (nGhostLayers[2])*sizeProd[2] + (nGhostLayers[3]+1)*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

//Even layers - Even Rows
g = (nGhostLayers[1] + 1)*sizeProd[1] + (nGhostLayers[2]+1)*sizeProd[2] + (nGhostLayers[3]+1)*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
\end{lstlisting}

\begin{lstlisting}[language=c, caption = loop routine]
  inline static void loopRedBlack3D(double *rhoVal,double *phiVal,long int *sizeProd, int *trueSize, int kEdgeInc, int lEdgeInc,
        long int g, long int gj, long int gjj, long int gk, long int gkk, long int gl, long int gll){

  gj = g + sizeProd[1];
  gjj= g - sizeProd[1];
  gk = g + sizeProd[2];
  gkk= g - sizeProd[2];
  gl = g + sizeProd[3];
  gll= g - sizeProd[3];

  for(int l = 0; l<trueSize[3]; l+=2){
    for(int k = 0; k < trueSize[2]; k+=2){
      for(int j = 0; j < trueSize[1]; j+=2){
        // msg(STATUS, "g=%d", g);
        phiVal[g] = 0.125*(phiVal[gj] + phiVal[gjj] +
                phiVal[gk] + phiVal[gkk] +
                phiVal[gl] + phiVal[gll] + rhoVal[g]);
        g	+=2;
        gj	+=2;
        gjj	+=2;
        gk	+=2;
        gkk	+=2;
        gl	+=2;
        gll	+=2;{subfigure}
      }
    g	+=kEdgeInc;
    gj	+=kEdgeInc;
    gjj	+=kEdgeInc;
    gk	+=kEdgeInc;
    gkk	+=kEdgeInc;
    gl	+=kEdgeInc;
    gll	+=kEdgeInc;
    }
  g	+=lEdgeInc;
  gj	+=lEdgeInc;
  gjj	+=lEdgeInc;
  gk	+=lEdgeInc;
  gkk	+=lEdgeInc;
  gl	+=lEdgeInc;
  gll	+=lEdgeInc;
  }

  return;
}
\end{lstlisting}
