%%%%%%%%%%%%%%%%%%%%%%%%%MG-Cycles%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
	\subsection{V-cycle, code}
	\label{sec:mg_V}
	\begin{lstlisting}[language=c, caption = Implementation of an recursive V-cycle]
void inline static mgVRecursive(int level, int bottom, int top, Multigrid *mgRho, Multigrid *mgPhi,
 									Multigrid *mgRes, const MpiInfo *mpiInfo){

	//Solve and return at coarsest level
	if(level == bottom){
		gInteractHalo(setSlice, mgPhi->grids[level], mpiInfo);
		mgRho->coarseSolv(mgPhi->grids[level], mgRho->grids[level], mgRho->nCoarseSolve, mpiInfo);
		mgRho->prolongator(mgRes->grids[level-1], mgPhi->grids[level], mpiInfo);
		return;
	}

	//Gathering info
	int nPreSmooth = mgRho->nPreSmooth;
	int nPostSmooth= mgRho->nPostSmooth;

	Grid *phi = mgPhi->grids[level];
	Grid *rho = mgRho->grids[level];
	Grid *res = mgRes->grids[level];

	//Boundary
	gInteractHalo(setSlice, rho, mpiInfo);
	gBnd(rho,mpiInfo);

	//Prepare to go down
	mgRho->preSmooth(phi, rho, nPreSmooth, mpiInfo);
	mgResidual(res, rho, phi, mpiInfo);
	gInteractHalo(setSlice, res, mpiInfo);
	gBnd(res, mpiInfo);

	//Go down
	mgRho->restrictor(res, mgRho->grids[level + 1]);
	mgVRecursive(level + 1, bottom, top, mgRho, mgPhi, mgRes, mpiInfo);

	//Prepare to go up
	gAddTo( phi, res );
	gInteractHalo(setSlice, phi,mpiInfo);
	gBnd(phi,mpiInfo);
	mgRho->postSmooth(phi, rho, nPostSmooth, mpiInfo);

	//Go up
	if(level > top){
		mgRho->prolongator(mgRes->grids[level-1], phi, mpiInfo);
	}
	return;
}
	\end{lstlisting}

\newpage
\begin{lstlisting}[language=c, caption = Implementation of an recursive V-cycle]
void mgVRegular(int level, int bottom, int top, Multigrid *mgRho, Multigrid *mgPhi,
 									Multigrid *mgRes, const MpiInfo *mpiInfo){

	//Gathering info
	int nPreSmooth = mgRho->nPreSmooth;
	int nPostSmooth= mgRho->nPostSmooth;
	int nCoarseSolv= mgRho->nCoarseSolve;


	//Down to coarsest level
	for(int current = level; current <bottom; current ++){
		//Load grids
		Grid *phi = mgPhi->grids[current];
		Grid *rho = mgRho->grids[current];
		Grid *res = mgRes->grids[current];

		//Boundary
		gInteractHalo(setSlice, phi,mpiInfo);
		gBnd(phi,mpiInfo);

		mgRho->preSmooth(phi, rho, nPreSmooth, mpiInfo);
		mgResidual(res, rho, phi, mpiInfo);
		mgRho->restrictor(res, mgRho->grids[current + 1]);
	}

	//Solve at coarsest
	gInteractHalo(setSlice, mgRho->grids[bottom], mpiInfo);
	gBnd(mgRho->grids[bottom],mpiInfo);
	mgRho->coarseSolv(mgPhi->grids[bottom], mgRho->grids[bottom], nCoarseSolv, mpiInfo);
	mgRho->prolongator(mgRes->grids[bottom-1], mgPhi->grids[bottom], mpiInfo);

	//Up to finest
	for(int current = bottom-1; current >-1; current --){
		//Load grids
		Grid *phi = mgPhi->grids[current];
		Grid *rho = mgRho->grids[current];
		Grid *res = mgRes->grids[current];


		//Prepare to go up
		gAddTo( phi, res );
		gInteractHalo(setSlice, phi,mpiInfo);
		gBnd(phi,mpiInfo);
		mgRho->postSmooth(phi, rho, nPostSmooth, mpiInfo);
		if(level > top)	mgRho->prolongator(mgRes->grids[current-1], phi, mpiInfo);
	}

	return;
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%Prolongators/Restrictors%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%Iterative Solvers%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Iterative solvers}
\subsection{Jacobian code}
\label{sec:jacobian}

\begin{lstlisting}[language=c, caption = Code snippet 2D jacobian]
  for(int c = 0; c < nCycles; c++){
    // Index of neighboring nodes
    int gj = sizeProd[1];
    int gjj= -sizeProd[1];
    int gk = sizeProd[2];
    int gkk= -sizeProd[2];

    for(long int g = 0; g < sizeProd[rank]; g++){
      tempVal[g] = 0.25*(	phiVal[gj] + phiVal[gjj] +
                phiVal[gk] + phiVal[gkk] + rhoVal[g]);

      gj++;
      gjj++;
      gk++;
      gkk++;
    }

    for(int q = 0; q < sizeProd[rank]; q++) phiVal[q] = tempVal[q];
    for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
  }
\end{lstlisting}

\newpage
\subsection{GS-RB 2D}
\label{sec:GS_RB_2D}
\begin{lstlisting}[language=c, caption = Main loop]
    for(int c = 0; c < nCycles;c++){

      //Increments
      int kEdgeInc = nGhostLayers[2] + nGhostLayers[rank + 2] + sizeProd[2];

      /**************************
       *	Red Pass
       *************************/
      //Odd numbered rows
      g = nGhostLayers[1] + sizeProd[2];
      loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);

      //Even numbered columns
      g = nGhostLayers[1] + 1 + 2*sizeProd[2];
      loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);

      for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);

      /***********************************
       *	Black pass
       **********************************/
      //Odd numbered rows
      g = nGhostLayers[1] + 1 + sizeProd[2];
      loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);

      //Even numbered columns
      g = nGhostLayers[1] + 2*sizeProd[2];
      loopRedBlack2D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, g, gj, gjj, gk, gkk);


      for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
    }

    return;
  }
\end{lstlisting}

\begin{lstlisting}[language=c, caption = Loop through grid]
  gj = g + sizeProd[1];
  gjj= g - sizeProd[1];
  gk = g + sizeProd[2];
  gkk= g - sizeProd[2];

  for(int k = 1; k < trueSize[2]; k +=2){
    for(int j = 1; j < trueSize[1]; j += 2){
      phiVal[g] = 0.25*(	phiVal[gj] + phiVal[gjj] +
                phiVal[gk] + phiVal[gkk] + rhoVal[g]);
      g	+=2;
      gj	+=2;
      gjj	+=2;
      gk	+=2;
      gkk	+=2;
    }
    g	+=kEdgeInc;
    gj	+=kEdgeInc;
    gjj	+=kEdgeInc;
    gk	+=kEdgeInc;
    gkk	+=kEdgeInc;
  }
\end{lstlisting}

\newpage
\subsection{GS-RB 3D if tests}
\label{sec:GS-RB_if}
\begin{lstlisting}[language=c, caption = GS-RB with if-tests]

  /*********************
   *	Red Pass
   ********************/
  g = sizeProd[3]*nGhostLayers[3];
  for(int l = 0; l < trueSize[3];l++){
    for(int k = 0; k < size[2]; k++){
      for(int j = 0; j < size[1]; j+=2){
        phiVal[g] = 0.125*(	phiVal[g+gj] + phiVal[g-gj] +
                  phiVal[g+gk] + phiVal[g-gk] +
                  phiVal[g+gl] + phiVal[g-gl] + rhoVal[g]);
        g	+=2;
      }
      if(l%2){
        if(k%2)	g+=1; else g-=1;
      } else {
        if(k%2) g-=1; else g+=1;
      }

    }
    if(l%2) g-=1; else g+=1;
  }

  for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
\end{lstlisting}

\newpage
\subsection{GS-RB 3D without if tests}
\begin{lstlisting}[language=c, caption = main routine]
/**************************
 *	Red Pass
 *************************/
//Odd layers - Odd Rows
g = nGhostLayers[1]*sizeProd[1] + nGhostLayers[2]*sizeProd[2] + nGhostLayers[3]*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

//Odd layers - Even Rows
g = (nGhostLayers[1]+1)*sizeProd[1] + (nGhostLayers[2]+1)*sizeProd[2] + nGhostLayers[3]*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

//Even layers - Odd Rows
g = (nGhostLayers[1])*sizeProd[1] + (nGhostLayers[2])*sizeProd[2] + (nGhostLayers[3]+1)*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

//Even layers - Even Rows
g = (nGhostLayers[1] + 1)*sizeProd[1] + (nGhostLayers[2]+1)*sizeProd[2] + (nGhostLayers[3]+1)*sizeProd[3];
loopRedBlack3D(rhoVal, phiVal, sizeProd, trueSize, kEdgeInc, lEdgeInc,
        g, gj, gjj, gk, gkk, gl, gll);

for(int d = 1; d < rank; d++) gSwapHalo(phi, mpiInfo, d);
\end{lstlisting}

\begin{lstlisting}[language=c, caption = loop routine]
  inline static void loopRedBlack3D(double *rhoVal,double *phiVal,long int *sizeProd, int *trueSize, int kEdgeInc, int lEdgeInc,
        long int g, long int gj, long int gjj, long int gk, long int gkk, long int gl, long int gll){

  gj = g + sizeProd[1];
  gjj= g - sizeProd[1];
  gk = g + sizeProd[2];
  gkk= g - sizeProd[2];
  gl = g + sizeProd[3];
  gll= g - sizeProd[3];

  for(int l = 0; l<trueSize[3]; l+=2){
    for(int k = 0; k < trueSize[2]; k+=2){
      for(int j = 0; j < trueSize[1]; j+=2){
        // msg(STATUS, "g=%d", g);
        phiVal[g] = 0.125*(phiVal[gj] + phiVal[gjj] +
                phiVal[gk] + phiVal[gkk] +
                phiVal[gl] + phiVal[gll] + rhoVal[g]);
        g	+=2;
        gj	+=2;
        gjj	+=2;
        gk	+=2;
        gkk	+=2;
        gl	+=2;
        gll	+=2;{subfigure}
      }
    g	+=kEdgeInc;
    gj	+=kEdgeInc;
    gjj	+=kEdgeInc;
    gk	+=kEdgeInc;
    gkk	+=kEdgeInc;
    gl	+=kEdgeInc;
    gll	+=kEdgeInc;
    }
  g	+=lEdgeInc;
  gj	+=lEdgeInc;
  gjj	+=lEdgeInc;
  gk	+=lEdgeInc;
  gkk	+=lEdgeInc;
  gl	+=lEdgeInc;
  gll	+=lEdgeInc;
  }

  return;
}
\end{lstlisting}
