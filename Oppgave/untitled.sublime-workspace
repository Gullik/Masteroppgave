{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"h",
				"h"
			],
			[
				"c",
				"c"
			],
			[
				"mg",
				"mg"
			],
			[
				"hello",
				"hellofunc"
			],
			[
				"grav",
				"grav_pot"
			],
			[
				"gra",
				"grav_pot"
			],
			[
				"force",
				"forceRK4"
			],
			[
				"initi",
				"initial_velocity"
			],
			[
				"v2",
				"v2_para"
			],
			[
				"b_",
				"b_length"
			],
			[
				"B",
				"Bx"
			],
			[
				"phase",
				"phasespace"
			],
			[
				"position",
				"positions"
			],
			[
				"xl",
				"xlabel"
			],
			[
				"la",
				"LATITUDE"
			],
			[
				"latit",
				"latitude"
			],
			[
				"phi",
				"phi"
			],
			[
				"plot",
				"plot_potential_and_electric_field"
			],
			[
				"con",
				"contourf"
			],
			[
				"potential",
				"potential"
			],
			[
				"k",
				"k_values"
			],
			[
				"x",
				"xmax"
			],
			[
				"xm",
				"xmax"
			],
			[
				"Omeg",
				"Omega_ele"
			],
			[
				"Omega",
				"Omega_ion"
			],
			[
				"dd",
				"ddTheta"
			],
			[
				"sin",
				"sinTheta"
			],
			[
				"conve",
				"convection"
			],
			[
				"v_",
				"v_phi"
			],
			[
				"pot",
				"potential"
			],
			[
				"E",
				"E_theta"
			],
			[
				"gradie",
				"gradient_phi"
			],
			[
				"v",
				"v_x"
			],
			[
				"step",
				"stepsize"
			],
			[
				"time",
				"timestep"
			],
			[
				"cross",
				"cross_product"
			],
			[
				"gradient",
				"gradient_theta"
			],
			[
				"kineti",
				"kinetic_perp"
			],
			[
				"kin",
				"kinetic_para"
			],
			[
				"vC",
				"vCrossB_y"
			],
			[
				"trim",
				"trimNumber"
			],
			[
				"y",
				"set_ylabel"
			],
			[
				"K_",
				"K_perp"
			],
			[
				"K",
				"K_perp"
			],
			[
				"v_p",
				"v_para"
			],
			[
				"vz",
				"vzShift"
			],
			[
				"C",
				"C1"
			],
			[
				"dv_",
				"dv_para"
			],
			[
				"plt",
				"plt"
			],
			[
				"Re",
				"Re"
			],
			[
				"By",
				"By"
			],
			[
				"magneti",
				"magneticField"
			],
			[
				"va",
				"vaSquared"
			],
			[
				"gradien",
				"gradient_phi"
			],
			[
				"po",
				"potential"
			],
			[
				"contour",
				"contourf"
			],
			[
				"gradient_",
				"gradient_theta"
			],
			[
				"p",
				"potential"
			],
			[
				"cbar",
				"cbar_labels"
			],
			[
				"contou",
				"contourPlot"
			],
			[
				"lamb",
				"lamb_end"
			],
			[
				"lati",
				"latitude"
			],
			[
				"phi_",
				"phi_start"
			],
			[
				"latitude",
				"latitude_index"
			],
			[
				"coe",
				"coefficients"
			],
			[
				"coef",
				"coefficients"
			],
			[
				"lam",
				"lambda_start"
			],
			[
				"to",
				"total_dr_z"
			],
			[
				"magn",
				"magneticField"
			],
			[
				"density",
				"densityConstant"
			],
			[
				"mag",
				"magConstant"
			],
			[
				"ma",
				"magneticField"
			],
			[
				"M",
				"MagField"
			],
			[
				"V",
				"V"
			],
			[
				"dipo",
				"dipoleVector"
			],
			[
				"dipole",
				"dipoleMoment"
			],
			[
				"di",
				"dipoleVector"
			],
			[
				"ax",
				"axArray"
			],
			[
				"grap",
				"graphRow"
			],
			[
				"graph",
				"graphScale"
			],
			[
				"yticks",
				"yticksLoc"
			],
			[
				"W",
				"W"
			],
			[
				"ve",
				"velocityMagnitude"
			],
			[
				"veloci",
				"velocityMagnitude"
			],
			[
				"dri",
				"drifty"
			],
			[
				"set",
				"set_title"
			],
			[
				"X",
				"X"
			],
			[
				"dV",
				"dVY"
			],
			[
				"e",
				"e"
			],
			[
				"start",
				"startRotationTime"
			],
			[
				"10",
				"10E-9"
			],
			[
				"kinetic",
				"kineticEnergy"
			],
			[
				"kine",
				"kineticEnergy"
			],
			[
				"Beryllium",
				"BerylliumTwo"
			],
			[
				"Charg",
				"ChargeDensity"
			],
			[
				"run",
				"runThermalize"
			],
			[
				"cut",
				"cutSquares"
			],
			[
				"slice",
				"slice2D"
			],
			[
				"xli",
				"xlim"
			],
			[
				"xlim",
				"xlimit"
			],
			[
				"electron",
				"electronList"
			],
			[
				"electr",
				"electronList"
			],
			[
				"norm",
				"normTemp"
			],
			[
				"data",
				"datapoints"
			],
			[
				"print",
				"printCorrelationDerivatives"
			],
			[
				"psi",
				"Psi1S"
			],
			[
				"lo",
				"localenergy1"
			],
			[
				"psi2P",
				"psi2P"
			],
			[
				"sa",
				"saveState"
			],
			[
				"loadS",
				"loadSavedState"
			],
			[
				"save",
				"saveState"
			],
			[
				"load",
				"loadSavedState"
			],
			[
				"r",
				"runNewSystem"
			],
			[
				"nA",
				"nAtomsInBins"
			],
			[
				"Bin",
				"radialBins"
			],
			[
				"n",
				"nAtomsInBins"
			],
			[
				"radial",
				"radialBins"
			],
			[
				"atoms",
				"nAtoms"
			],
			[
				"stat",
				"statisticalValues"
			],
			[
				"rel",
				"relEnergyError"
			],
			[
				"sta",
				"statisticalValues"
			],
			[
				"dat",
				"dataCycles"
			],
			[
				"ene",
				"energy"
			],
			[
				"en",
				"energy"
			],
			[
				"Helium",
				"HeliumSimpleAnalytical"
			],
			[
				"energy",
				"energyFig"
			],
			[
				"HeliumSimple",
				"HeliumSimpleAnalytical_alpha_beta"
			],
			[
				"alpha",
				"ALPHA"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "\n	\\section{Poisson Solvers}\n\n		In the Particle in Cell method, instead of calculating the forces directly between the particles, we first calculate the electric field from all the particles and then use that to calculate the individual force on the particles. From the particles we use a weighting scheme to obtain a charge density on a grid. Then we can use Poisson's equation \\cref{eq:poisson} to calculate the electric potential from the charge density, before computing the electric field from the potential. So we need an efficient Poisson solver.\n\n		\\begin{align}\n			\\nabla ^2 \\Phi &= -\\rho \\qquad \\text{in} \\qquad \\Omega \\label{eq:poisson}\n		\\end{align}\n\n		The problem also need boundary conditions in which we will focus on periodic, Dirichlet and Neumann boundary conditions.\n\n		\\subsection{Spectral Methods}\n			The spectral methods is based on Fourier transforms of the problem and solving the problem in it's spectral version, see \\cite{Shen1994} for an implementation of an spectral poisson solver. They are efficient solvers that can be less, but can be inaccurate for complex geometries.\n\n			When looking for a solution with a spectral method we first rewrite the functions as Fourier series, which for the three-dimensional Poisson equation would be\n\n			\\begin{align}\n				\\nabla^2 \\sum A_{j,k,l} e^{i(jx + ky + lz)} &= \\sum B_{j,k,l} e^{i(jx + ky + lz)}\n				\\intertext{From there we get a relation between the coefficients}\n				A_{j,k,l} &= -\\frac{B_{j,k,l}}{j^2 + k^2 + l^2}\n				\\intertext{Then we compute the Fourier transform of the right hand side obtaining the coefficients \\(B_{j,k,l}\\). We compute all the coefficients \\(A_{j,k,l}\\) from the relation between the coefficients. At last we perform a inverse Fourier transform of the left hand side obtaining the solution.}\n			\\end{align}\n\n\n\n		\\subsection{Finite Element Methods}\n\n			The finite element is a method to numerically solve a partial differential equations (PDE) first transforming the problem into a variational problem and then constructing a mesh and local trial functions, see \\cite{Sandve2011} for a more complete discussion.\n\n			To transform the PDE to a variational problem we first multiply the PDE by a test function \\(v\\), then it is integrated using integration by parts on the second order terms. Then the problem is separated into two parts, the bilinear form \\(a(u,v)\\) containing the unknown solution and the test function and the linear form \\(L(v)\\) containing only the test function.\n\n			\\begin{align}\n				a(u,v) = L(v)	\\qquad v\\epsilon \\hat{V}\n			\\end{align}\n\n			Next we construct discrete local function spaces of that we assume contain the trialfunctions and testfunctions. The function spaces often consists of locally defined functions that are \\(0\\) except in a close neighbourhood of a mesh point, so the resulting matrix to be solved is sparse and can be computed quickly. The matrix system is then solved by a suiting linear algebra algorithm, before the solution is put together.\n\n\n	\\section{Multigrid}\n		The multi grid, MG, method used to solve the Poisson equation and obtain the electric field is a widely used and highly efficient solver for elliptic equations, having a theoretical scaling of \\(\\order{N}\\) \\citep{Press1987}, where \\(N\\) is the grid points. Here I will go through the main theory and algorithm behind the method, as explained in more detail in \\citep{Press1987,Trottenberg2000} as well as go through some of possible algorithms to parallelize the method.\n\n		We want to solve a linear elliptic problem, \n			\\begin{align}\n				\\mathcal{L} u = f\n			\\end{align}\n		where \\(\\mathcal{L}\\) is a linear operator, \\(u\\) is the solution and \\(f\\) is a source term. In our specific case the operator is given by the laplacian, the source term is given by the charge density and we solve for the electric potential.\n\n		We discretize the equation onto a grid of size \\(q\\).\n		\\begin{align}\n			\\mathcal{L}_q u_q &= f_q \\label{eq:difference}\n		\\end{align}\n\n		Let the error, \\(v_q\\) be the difference between the exact solution and an approximate solution to the difference equation (\\ref{eq:difference}), \\( v_q = u_q - \\tilde{u}_q \\). Then we define the residual as what is left after using the approximate solution in the equation.\n\n		\\begin{align}\n			d_q &= \\mathcal{L}_q \\tilde{u}_q - f_q\n		\\end{align}\n\n		Since \\(\\mathcal{L}\\) is a linear operator the error satisfies the following relation\n\n		\\begin{align}\n			\\mathcal{L}_q v_q &= (\\mathcal{L}u_q - f_q) - (\\mathcal{L}\\tilde{u}_q  - f_q)\n			\\\\\n			\\mathcal{L}_q v_q &= - d_q \\label{eq:diff_MG}\n		\\end{align}\n\n		In the multigrid methods instead of solving the equation directly here, we set up a system nested coarser square grids, \\(\\mathfrak{T}_1 \\subset \\mathfrak{T}_2 \\subset \\cdots \\subset \\mathfrak{T}_\\ell\\), where \\(1\\) is the coarsest grid and \\(\\ell\\) is the finest. Then the main thought behind the methods is that instead of solving the problem directly on the initial grid, we use restriction, \\( \\mathcal{R} \\), and interpolation, \\( \\mathcal{P} \\), operators to change the problem between the different grid levels and solve them on there. (Fix previous sentence) Due to the fewer grid points the problem is faster to solver on the coarser grid levels than on the fine grid.\n\n		If we then apply a restriction operator on the residual we go down a level on the grids and the opposite for the interpolation operator.\n\n		\\begin{align}\n			\\mathcal{R} d_q = d_{q-1} \\qquad \\text{and} \\qquad \\mathcal{P} d_q = d_{q + 1}  \n		\\end{align}\n\n\n		\\subsection{Algorithm}\n			A sequential algorithm for a two grid V shaped algorithm, where the coarse grid and fine grid has respectively \\(q = 1,2\\).\n\n		\\begin{itemize}\n			\\item Initial approximation. \\(\\tilde{u}\\) \n			\\item for \\(i < \\) nCycles:\n				\\begin{itemize}\n					\\item Presmooth: \\(\\hat{u}_2 = S_{pre}(u)_2\\)\n					\\item Calculate defect: \\( d_2 = f_2 - \\mathcal{L}\\hat{u}_2\\)\n					\\item Restrict defect: \\( d_1 = Rd_2 \\)\n					\\item Initial guess: 	\\( \\tilde{u}_1 = 0 \\)\n					\\item Solve (G-S RB): 	\\( L_1 \\tilde{u}_1 = d_1 \\)\n					\\item Interpolate:		\\( \\tilde{u}_2 = I \\tilde{u}_1 \\)\n					\\item Add correction:	\\( u^{new}_2 = \\hat{u}_2 + \\tilde{u}_2 \\)\n				\\end{itemize}\n		\\end{itemize}\n\n		\\subsection{Smoothing: Gauss-Seidel}\n			Relaxation methods, such as Gauss-Seidel, work by looking for the setting up the equation as a diffusion equation, and then solve for the equilibrium solution.\n\n			So suppose we want to solve the elliptic equation\n			\\begin{align}\n				\\mathcal{L}u &= \\rho\n				\\intertext{Then we set it up as a diffusion equation}\n				\\pdv{u}{t} &= \\mathcal{L}u - \\rho\n				\\intertext{By starting with an initial guess for what \\(u\\) could be the equation will relax into the equilibrium solution \\(\\mathcal{L}u = \\rho\\). By using a Forward-Time-Centered-Space scheme to discretize, along with the largest stable timestep \\(\\Delta t = \\Delta^2 / 2^d\\) (Double check the factor.), we arrive at Jacobi's method, which is an averaging of the neighbors in addition to a contribution from the source term. By using the already updated values for in the calculation of the \\(u^{new}\\) we arrive at the method called Gauss-Seidel which for two dimensions is the following}\n				u^{n+1}_{i,j} &= \\frac{1}{4}\\left( u^n_{i+1,j} + u^{n +1}_{i-1,j} + u^{n}_{i, j+1} + u^{n+1}_{i,j-1}  \\right) - \\frac{\\Delta^2 \\rho_{i,j}}{4}\n			\\end{align}\n\n			To achieve a vectorization of the calculation of \\(u^{n+1}_{i,j}\\) we will use Red and Black ordering, first calculating the odd nodes and then the even nodes, so the method has the available information. \n\n\n\n\n	\\section{Parallelization}\n		For the parallelization of an algorithm there is two obvious issues that need to be addressed to ensure that the algorithm retains a high degree of parallelization; communication overhead and load imbalance \\citep{Trottenberg}. Communication overhead means the time the computational nodes spend communicating with each other, if that is longer than the actual time spent computing the speed of the algorithm will suffer, and load imbalance appears if some nodes need to do more work than others causing some nodes to stand idle.\n\n		Here we will focus on multigrid of a 3D cubic (to be expanded to rectangular cubes) grid, where each grid level has half the number of grid points. We will use grid partitioning to divide the domain, GS-RB (Gauss-Seidel Red-Black) as both a smoother and a coarse grid solver.\n\n		We need to investigate how the different steps: interpolation, restriction, smoothing and the coarse grid solver, in a MG method will handle parallelization.\n\n		\\subsection{Grid Partition}\n			\\label{sec:grid_partitioning}\n			There are several well explored options for how a multigrid method can be parallized, for example Domain Decomposition \\citep{Arraras2015}, Algebraic Multigrid \\citep{StUben2001}, see \\citet{Chow2006} for a survey of different techniques. Here we will focus on Geometric Multigrid (GMG) with grid partitioning used for the parallelization, as described in the books \\cite{Trottenberg2000,Trottenberg}.\n\n			With grid partitioning we divide the grid \\(\\mathcal{T}\\) into geometric subgrids, then we can let each processes handle one subgrid each, as we will see it can be useful when using the G-S RB smoothing to let the subgrids overlap 1 layer deep. since it on the edges of the subgrid it will need the adjacent node values.\n\n		\\subsection{Distributed and accumulated data}\n			During the parallel execution of the code there can be useful to keep track of the different data structures and what needs to be accumulated over all the computational nodes and what only needs to be distributed on the individual computational nodes. \n\n			\\begin{itemize}\n				\\item \\(u\\) solution (\\(\\Phi\\))\n				\\item \\(w\\) temporary correction\n				\\item \\(d\\) defect\n				\\item \\(f\\) source term (\\(\\rho\\)) \n				\\item \\(\\mathcal{L}\\) differential operator\n				\\item \\(\\mathcal{I}\\) interpolation operator\n				\\item \\(\\mathcal{R}\\) restriction operator\n				\\item \\( \\va{u}\\) Bold means accumulated vector\n				\\item \\( \\tilde{\\va{ u }} \\) is the temporary smoothed solution\n			\\end{itemize}\n\n			\\begin{itemize}\n				\\item Accumulated vectors:	\\(\\va{u}_q\\), \\( \\hat{\\va{u}}_q \\), \\(\\tilde{\\va{u}}_q\\), \\(\\hat{\\va{w}}_q\\) \\(\\va{w}_{q-1}\\), \\(\\va{I}\\),\\(\\va{R}\\)\n				\\item Distributed vectors:  \\( f_q \\), \\(d_q\\), \\(d_{q-1}\\)\n			\\end{itemize}\n			Algorithm: P is the number of processes\n			\\begin{itemize}\n				\\item If (q == 1): Solve: \\(\\sum_{s=1}^P\\mathcal{L}_{s,1} \\va{u}_1 = \\sum_{s=1}^Pf_{s,1}\\)\n				\\item else:\n					\\begin{itemize}\n						\\item Presmooth: \\( \\hat{\\va{u}}_q = \\mathcal{S}_{pre} \\va{u_q}\\)\n						\\item Compute defect: \\( d_q = f_q - \\mathcal{L}_q \\hat{\\va{u}}_q \\)\n						\\item Restrict defect: \\( d_{q -1} = \\mathcal{R} d_q \\)\n						\\item Initial guess:   \\( \\va{w}_{q-1} = 0 \\)\n						\\item Solve defect system: \\( \\va{w}_{q-1} = PMG(\\va{w}_{q-1}, d_{q -1} ) \\)\n						\\item Interpolate correction: \\( \\va{w}_q = \\mathcal{R} \\va{w}_{q-1} \\)\n						\\item Add correction:		\\( \\tilde{\\va{u}}_q = \\hat{\\va{u}}_q + \\va{w}_q \\)\n						\\item Post-smooth:			\\( \\va{u}_q = \\mathcal{S}_{post}\\)\n					\\end{itemize}\n			\\end{itemize}\n\n\n		\\subsection{Smoothing}\n			Will use G-S with R-B ordering, supposedly good parallel properties \\citep{Chow2006}. Follow algorithm I in \\cite{Adams2001} (alternatively try to implement the more complicated version)?\n\n			We have earlier divided the grid into subgrids, with overlap, as described in subsection \\ref{sec:grid_partitioning} and given each processor responsibility for a subgrid. Then do a a GS-RB method we start with an approximation of \\(u^{n}_{i,j}\\). Then we will obtain the next iteration by the following formula\n\n			\\begin{align}\n				u^{n+1}_{i,j} &= \\frac{1}{4}\\left( u^n_{i+1,j} + u^{n +1}_{i-1,j} + u^{n}_{i, j+1} + u^{n+1}_{i,j-1}  \\right) - \\frac{\\Delta^2 \\rho_{i,j}}{4}\n			\\end{align}\n\n			We can see that the for the inner subgrid we will have no problems since we have all the surrounding grid points. On the edges we will need the adjacent grid points that are kept in the other processors. To avoid the algorithm from asking neighboring subgrids for adjacent grid points each time it reaches a edge we instead update the entire neighboring column at the start. So we will have a 1-row overlap between the subgrids, that need to be updated for each iteration.\n\n\n		\\subsection{Restriction}\n			For the transfer down a grid level, to the coarser grid we will use a half weighting stencil. In two dimensions it will be the following\n\n			\\begin{align}\n				\\mathcal{R} &= \\frac{1}{8}\n				\\begin{bmatrix}\n					0 & 1 & 0\n					\\\\\n					1 & 4 & 1\n					\\\\\n					0 & 1 & 0\n				\\end{bmatrix}\n			\\end{align}\n\n			With the overlap of the subgrids we will have the necessary information to perform the restriction without needing communication between the processors \\citep{Trottenberg}.\n\n		\\subsection{Interpolation}\n			For the interpolation we will use bilinear interpolation:\n\n			\\begin{align}\n				\\mathcal{I} &= \\frac{1}{4}\n				\\begin{bmatrix}\n					1 & 2 & 1\n					\\\\\n					2 & 8 & 2\n					\\\\\n					1 & 2 & 1\n				\\end{bmatrix}\n			\\end{align}\n\n			Since the interpolation is always done after GS-RB iterations the the outer part overlapped part of the grid updated, and we can have all the necessary information.\n\n		\\subsection{Scaling}\n			\\subsubsection{Volume-Boundary effect}\n			While a sequential MG algorithm has a theoretical scaling of \\(\\order{N}\\) \\citep{Press1987}, where \\(N\\) is the number of grid points, an implementation will have a lower scaling efficiency due to interprocessor communication. We want a parallel algorithm that attains a high speedup with more added processors \\(P\\),  compared to sequential \\(1\\) processor algorithm. Let \\(T(P)\\) be the computational time needed for solving the problem on \\(P\\) processors. Then we define the speedup \\(S(P)\\) and the parallel efficiency \\(E(P)\\) as\n\n			\\begin{align}\n				S(P) = \\frac{T(1)}{T(P)} \\qquad E(P) = \\frac{S(P)}{P}\n			\\end{align} \n\n			A perfect parallel algorithm would the computational time would scale inversely with the number of processors, \\(T(P) \\propto 1/P\\) leading to \\( E(P) =1 \\). Due to the necessary interprocessor communication that is generally not achievable. The computational time of the algorithm is also important, if the algorithm is very slow but has good parallel efficiency it is often worse than a fast algorithm with a worse parallel efficiency.\n\n			The parallel efficiency of an algorithm is governed by the ratio between the time of communication and computation, \\(T_{comm}/T_{comp}\\). If there is no need for communication, like on \\(1\\) processor, the algorithm is perfectly parallel efficient. In our case the whole grid is diveded into several subgrids, which is assigned to different processors. In many cases the time used for computation is roughly scaling with the interior grid points, while the communication time is scaling with the boundaries of the subgrids. If a local solution method is used on a local problem it is only the grid points at the boundary that needs the information from grid points on the other processors. Since the edges has lower dimensionality than the inner grid points. So when the problem is is increasing the time for computation grows faster than the time for communication, and a parallel algorithm often has a higher parallel efficiency on a larger problem. This is called the Boundary-Volume effect.\n\n			\\subsubsection{Parallel complexity}\n				The complexities, as in needed computational work, of sequential and parallel MG cycles is calculated in \\cite{Trottenberg} and is shown in \\cref{tab:parallel_complexity}. In the table we can see that in the parallel case there is a substantial increase in the complexity in the case of \\(W\\) cycles compared to \\(V\\) cycles. In the sequential case the change in complexity when going to a \\(W\\) cycle is not dependent on the problem size, but it is in the parallel case. \n\n				\n			\\begin{table}\n				\\centering\n				\\begin{tabular}{ c  c c c}\n					& Cycle & Sequential & Parallel\n				  	\\\\  \\hline\n				  	MG & V & \\(\\order{N}\\) & \\(\\order{\\log N}\\)\n				  	\\\\ \n				  	& W & $\\order{N}$ & $\\order{\\sqrt{N}}$\n				  	\\\\ \\hline\n					FMG & V & $\\order{N}$ & $\\order{\\log^2 N}$\n					\\\\\n					& W & $\\order{N}$ & \\( \\order{\\sqrt{N} \\log{N}} \\)\n				\\end{tabular}\n				\\caption{The parallel complexities of sequential and parallel multigrid cycles}\n				\\label{tab:parallel_complexity}\n			\\end{table}\n\n\n			\n",
			"file": "chapters/method.tex",
			"file_size": 16451,
			"file_write_time": 130898001137941394,
			"settings":
			{
				"buffer_size": 16457,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/appendix.tex",
			"settings":
			{
				"buffer_size": 13204,
				"line_ending": "Windows"
			}
		},
		{
			"file": "chapters/introduction.tex",
			"settings":
			{
				"buffer_size": 4780,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Master-Thesis.tex",
			"settings":
			{
				"buffer_size": 2450,
				"line_ending": "Unix"
			}
		},
		{
			"file": "chapters/alt_methods.tex",
			"settings":
			{
				"buffer_size": 6629,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				]
			],
			[
				"Packages/C++/C++ Single File.sublime-build",
				"Run"
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "laate",
		"selected_items":
		[
			[
				"laate",
				"LaTeXTools: Reconfigure and migrate settings"
			],
			[
				"late",
				"LaTeXTools: Reconfigure and migrate settings"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2deb499853c4371624f5a07e27c334aa' + 'bf8c4e67d14fb0525ba4f89698a6d7e1'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/gullik/Documents/Masteroppgave/Oppgave",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters"
	],
	"file_history":
	[
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/GTO.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/extras.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/molecules.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/conclusions",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/introduction.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/verification.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/untitled",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/discussion.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/conclusions.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/method.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/appendix.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/results.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/alt_methods.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/abstract.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/para.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/untitled.sublime-project",
		"/home/gullik/Documents/Masteroppgave/Oppgave/discussion",
		"/home/gullik/Documents/Masteroppgave/Oppgave/Master-Thesis.aux",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/methods.aux",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/methods.blg",
		"/home/gullik/Documents/Masteroppgave/Oppgave/bibs/bibliography.bib",
		"/home/gullik/Documents/Masteroppgave/Oppgave/bibs/10.1007%2F3-540-45492-6_21.bib",
		"/home/gullik/Documents/Masteroppgave/code/multigrid/src/input.c",
		"/home/gullik/Documents/Masteroppgave/code/multigrid/src/grid.c",
		"/home/gullik/Documents/Masteroppgave/code/multigrid/src/shortcut.c",
		"/home/gullik/Documents/Masteroppgave/code/multigrid/MG_par.sublime-project",
		"/home/gullik/Documents/Masteroppgave/code/multigrid/src/makefile",
		"/home/gullik/Documents/Masteroppgave/code/source_periodic/src/makefile",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_6/report/Report_6.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_7/source/draw_map.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_5/source/potential_grid.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_6/source/convection.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_5/report/Report_5.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_8/report/Report_8.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_9/source/stability.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_9/report/Report_9.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_3/source/dipfield_rk4.py",
		"/home/gullik/Documents/Masteroppgave/Oppgave/Master-Thesis.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/methods.tex",
		"/home/gullik/Documents/Masteroppgave/code/source_periodic/src/fmg/fmg_P.c",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/Project_3.tex",
		"/home/gullik/Documents/Masteroppgave/code/source_periodic/src/main.c",
		"/home/gullik/Documents/Masteroppgave/Oppgave/Master-Thesis.sublime-project",
		"/home/gullik/Documents/Masteroppgave/Oppgave/chapters/fmg-method.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/atoms.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/helium_atom.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/monte_carlo.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/master-thesis.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/main/fmg-method.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/Chapter/abstract.tex",
		"/home/gullik/Documents/Masteroppgave/Oppgave/Main/Master-Thesis.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_3/source/dipoleField_rewritten.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_3/report/Report_3.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_9/source/derivatives.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/notes/status_update.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/notes/comments.tex",
		"/home/gullik/Documents/CompPhys2_office306/sympyMath/localEnergyAnalytic.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_8/source/dispersion.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_9/source/dispersion.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_4/report/Report_4.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_4/source/wave.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_3/source/temp/rk4.cpp",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_7/report/Report_7.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_2/report/Report_2.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_2/source/EcrossBDrift.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_1/source/Single_Particle_Motion.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_1/Report/Report_1.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_7/source/facs.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_7/source/convection.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_6/source/potential_grid.py",
		"/usr/local/lib/python2.7/dist-packages/numpy/lib/_datasource.py",
		"/usr/local/lib/python2.7/dist-packages/numpy/lib/npyio.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_6/potential_grid.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_3/source/dipoleField.py",
		"/home/gullik/Documents/molecular-dynamics-fys3150/Report/Molecular_Dynamics_Report.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_6/report/test/untitled.tex",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_3/Report_3.tex",
		"/home/gullik/Documents/INF5620-Gullik/wave_project/solver.py",
		"/usr/lib/pymodules/python2.7/matplotlib/axes.py",
		"/home/gullik/Documents/INF5620-Gullik/wave_project/main.py",
		"/usr/local/lib/python2.7/dist-packages/numpy/core/numeric.py",
		"/home/gullik/Documents/CompPhys2_office306/source/python/energyLevels.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Sommerjobb_Oppgaver/Exercise_2/source/Single_Particle_Motion.py",
		"/home/gullik/Documents/Plasma Sommerjobb/Report_1/Report_1.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/conclusions.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/verification.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/beryllium_neon.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/optimisation.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/project_3.sublime-project",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/bibliography.bib",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/density_plots.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/temp_delete.tex",
		"/home/gullik/Documents/FYS4460/molecular-dynamics-2/python_framework/mdconfig.py",
		"/home/gullik/Documents/FYS4460/molecular-dynamics-2/python_framework/python_plots.py",
		"/home/gullik/Documents/FYS4460/molecular-dynamics-2/python_framework/run.py",
		"/home/gullik/Documents/Søknader og CV Gullik/Open application Norsk regnesentral.tex",
		"/home/gullik/Documents/Søknader og CV Gullik/Cover lett mal riktig.tex",
		"/home/gullik/Documents/Søknader og CV Gullik/Application DNV summer project (Gullik Killie).tex",
		"/home/gullik/Documents/CompPhys2_office306/source/python/blocking_plotter.py",
		"/home/gullik/Documents/FYS4460/molecular-dynamics/python_framework/run.py",
		"/home/gullik/Documents/Fys4460/Exam_answers/Exam_answers.tex",
		"/home/gullik/Documents/Fys4460/molecular-dynamics/python_framework/velocityplots.py",
		"/home/gullik/Documents/Fys4460/molecular-dynamics/python_framework/python_plots.py",
		"/home/gullik/Documents/Fys4460/molecular-dynamics/python_framework/mdconfig.py",
		"/home/gullik/Documents/Fys4460/molecular-dynamics/python_framework/run.py",
		"/home/gullik/Documents/Fys4460/Percolation/matlab_programs/percwalk.c",
		"/home/gullik/Documents/molecular-dynamics-fys3150/python_plots.py",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_1/project1_2015.tex",
		"/home/gullik/Downloads/AGF-211_Permeability_Gullik.tex",
		"/home/gullik/Documents/Fys4460/Exam_answers.tex",
		"/home/gullik/Downloads/plotmap.py",
		"/home/gullik/Documents/discussion.tex",
		"/home/gullik/Documents/04_hydrography.tex",
		"/home/gullik/Documents/AGF311__811_Report2014.tex",
		"/home/gullik/Documents/CompPhys2_office306/source/python/run_script.py",
		"/home/gullik/Documents/CompPhys2_office306/source/python/Parallel_compare_plotter.py",
		"/home/gullik/Documents/CompPhys2_office306/source/python/alpha_beta_plotter.py",
		"/home/gullik/Documents/CompPhys2_office306/source/energyLevels.py",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/extras.aux",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/verification.tex",
		"/home/gullik/Documents/Fys4460/Report/Molecular_Dynamics_Report.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/Project_3.toc",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/temp_delete.tex",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_3/Project_3.aux",
		"/home/gullik/Documents/CompPhys2_office306/Report/Report_2/Project_2.tex",
		"/home/gullik/Documents/Søknader og CV Gullik/søknader og cv gullik/jobbdokumenter/Application DNV/Cover lett mal riktig.tex",
		"/home/gullik/Documents/Søknader og CV Gullik/søknader og cv gullik/jobbdokumenter/Application DNV/Application DNV summer project (Gullik Killie).tex",
		"/home/gullik/Documents/CompPhys2_office306/sympyMath/derivatives.py"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"subgrid",
			"itemize",
			"ngrid ",
			"ngrid",
			" iu",
			"iu",
			"since",
			"periodic",
			"lcfree",
			"tic",
			"phasespace",
			"update",
			"\\Phi",
			"Phi",
			"pl.",
			"pl",
			"\\va",
			"pl",
			"print",
			"Bz",
			"subfig",
			"sub",
			"table",
			"print",
			"time",
			"oxygen",
			"\\vb",
			"m_e",
			"si",
			"should have",
			"should",
			"hence",
			"actually",
			".py",
			"py",
			".py",
			"cite",
			"Koput2011PCCP",
			"\\sigma^*",
			"\\sigma",
			"QUA:QUA560090204",
			"Koput:2011:PCCP",
			"cite",
			"citet",
			"cite",
			"\\cite",
			"Calculated in derivatives.py.",
			"verification",
			"eq:laplacianIntermediate",
			"fig02:timestep",
			"EnergyVsAlphaHeliumSimpleAnalytical",
			"Head",
			"yes",
			"tab:energyReference",
			"{figures/",
			"{figure",
			"tab",
			"figures",
			"None",
			"\\^",
			"Psi_T",
			"phi",
			"py",
			"))"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "chapters/method.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16457,
						"regions":
						{
						},
						"selection":
						[
							[
								15942,
								15942
							]
						],
						"settings":
						{
							"spell_check": true,
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4947.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/home/gullik/Documents/CompPhys2_office306/Report/Report_3/sections/appendix.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13204,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3825.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "chapters/introduction.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4780,
						"regions":
						{
						},
						"selection":
						[
							[
								468,
								468
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1428.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 3,
					"file": "Master-Thesis.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2450,
						"regions":
						{
						},
						"selection":
						[
							[
								2450,
								2450
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1479.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "chapters/alt_methods.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6629,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 25.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.639976275208,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 131.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 112.0
	},
	"pinned_build_system": "",
	"project": "untitled.sublime-project",
	"replace":
	{
		"height": 46.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 234.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
